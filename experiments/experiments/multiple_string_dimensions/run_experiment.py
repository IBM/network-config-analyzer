"""Experiment Description:

Parameters that we can play with:
1. number of dimensions (#dims)?
2. number of cubes (#cubes)?
3. how many string dimensions and integer dimensions?
4. overlapping and non-overlapping cubes?
5. dimensions ordering.
6. types of operations - creation, contained_in, add_cube, add_hole.
*** I skip the membership check since it is clear that CanonicalHyperCubeSet is more effective there.


Questions:
1. How does CanonicalHyperCubeSet compare to Z3ProductSet when all dimensions are string, #dims is fixed, and #cubes
is increasing?
    1.1. when the cubes are non-overlapping.
    1.2. when the cubes are overlapping.
2. How does CanonicalHyperCubeSet compare to Z3ProductSet when we have mixed dimensions? #dims is fixed, half are
strings, and half are integers? Interleaved. (int, string, int, string, ...)
    3.1. non-overlapping
    3.2. overlapping
3. Dimensions ordering: Is it better to place dimensions that are more complex (strings) earlier or later?
Play with how the dimensions are ordered, and see if we get some clear results on that.
4. Is Z3ProductSetSolver sensitive to constraint length?

Sketch:

Experiment 1: Non-overlapping string dimensions only. V
- fix the number of dimensions to a small number of values.
- increase the number of cubes from ??? to ???.
- the cubes will be generated by creating a single dimension, and then duplicating it.
- The string constraints will be a combination of exact match and prefix.
*** I can copy most of the code from multiple integer dimensions, and just change a few things.

Expectations:
- The results will be similar to multiple integer dimensions, but the advantage for z3 will show-up earlier,
as it becomes more efficient with strings faster than with integers.

Experiment 2: Overlapping string dimensions only. V
- Same as the above, but with overlapping cubes.

Expectation:
- Similar to the previous one, but, as in multiple integer dimensions, we should see that z3 is not that affected by
this, and CanonicalHyperCubeSet is very much so.

Experiment 3: Mixed string-integer dimensions, with interleaved dimensions. V
- Same as the above, but with mixed dimensions.
- Repeat overlapping and non-overlapping versions.
- Experiment with different dimensions ordering. strings first, strings last, interleaved.

Expectation:
- I expect the results to be quite similar to the previous 2 experiments.
- I think that the dimensions ordering should have some effect.
- I think that placing the more complex dimensions first should be most efficient, since we will have to duplicate
it less times.

"""
# TODO: rename this file to string only experiment
# TODO: separate between the mixed and the string only experiments

import logging
import string
from pathlib import Path
from typing import Type

from nca.CoreDS.CanonicalHyperCubeSet import CanonicalHyperCubeSet
from nca.CoreDS.CanonicalIntervalSet import CanonicalIntervalSet
from nca.CoreDS.DimensionsManager import DimensionsManager
from nca.CoreDS.MinDFA import MinDFA
from experiments.experiments.experiment_utils import Timer, get_dimension_names, load_results, \
    filter_on_key_value, save_results
from experiments.experiments.multiple_integer_dimensions.run_experiment import save_results_to_csv, plot_results
from z3_sets.z3_integer_set import Z3IntegerSet
from z3_sets.z3_product_set import Z3ProductSet
from z3_sets.z3_simple_string_set import Z3SimpleStringSet

logging.basicConfig(level=logging.INFO)
MIN_VALUE = 0
MAX_VALUE = 100_000


def non_overlapping_string_set_generator():
    letters = list(string.ascii_letters + string.digits)
    for letter in letters:
        exact_match = letter * 5
        prefix = (letter * 5) + '/' + (letter * 5) + '/*'
        yield [exact_match, prefix]


def non_overlapping_interval_generator():
    start = 10
    step = 10
    while True:
        yield [start, start + step]
        start = start + 2 * step


def non_overlapping_cube_generator(dim_types: list[Type]):
    string_set_generator = non_overlapping_string_set_generator()
    interval_set_generator = non_overlapping_interval_generator()
    for str_set, interval in zip(string_set_generator, interval_set_generator):
        cube = []
        for t in dim_types:
            if t == int:
                cube.append(interval)
            elif t == str:
                cube.append(str_set)
        yield cube


def overlapping_cube_generator(dim_types: list[Type]):
    string_set_generator = non_overlapping_string_set_generator()
    interval_set_generator = non_overlapping_interval_generator()

    def get_next(i: int):
        if dim_types[i] == int:
            return next(interval_set_generator)
        elif dim_types[i] == str:
            return next(string_set_generator)

    curr_i = 0
    curr_set = get_next(curr_i)
    while True:
        prev_i = curr_i
        prev_set = curr_set
        curr_i = (curr_i + 1) % len(dim_types)
        curr_set = get_next(curr_i)
        cube = []
        for i in range(len(dim_types)):
            if i == prev_i:
                cube.append(prev_set)
            elif i == curr_i:
                cube.append(curr_set)
            else:
                cube.append(None)   # getting None means that the dimension is not active.
        yield cube


def convert_cube(cube: list, cls, dim_types: list[Type], dim_names: list[str]):
    if cls == Z3ProductSet:
        interval_cls = Z3IntegerSet
        str_cls = Z3SimpleStringSet
    elif cls == CanonicalHyperCubeSet:
        interval_cls = CanonicalIntervalSet
        str_cls = MinDFA
    else:
        raise ValueError

    converted_cube = []
    active_dims = []
    for i, (s, t) in enumerate(zip(cube, dim_types)):
        if s is None:
            continue
        if t == int:
            converted_s = interval_cls.get_interval_set(s[0], s[1])
        else:
            converted_s = str_cls.from_wildcard(s[0]) | str_cls.from_wildcard(s[1])
        converted_cube.append(converted_s)
        active_dims.append(i)

    active_dims = [dim_names[d] for d in active_dims]
    return converted_cube, active_dims


def init_dim_manager(dim_names: list[str], dim_types: list[Type]):
    dim_manager = DimensionsManager()
    for name, t in zip(dim_names, dim_types):
        if t == int:
            dim_manager.set_domain(name, DimensionsManager.DimensionType.IntervalSet)
        else:
            dim_manager.set_domain(name, DimensionsManager.DimensionType.DFA)
            

def run_experiment(overlapping: bool):
    n_dims_options = [4, 8, 12]
    n_cubes_start = 3
    n_cubes_step = 3
    n_cubes_end = 24
    # n_cubes_end = 15  # for running quickly TODO: comment this

    n_cubes_options = list(range(n_cubes_start, n_cubes_end + 1, n_cubes_step))
    # hyper_cube_set_classes = [CanonicalHyperCubeSet, Z3ProductSet, Z3ProductSetDNF]
    hyper_cube_set_classes = [Z3ProductSet, CanonicalHyperCubeSet]
    results = []

    for n_dims in n_dims_options:
        dim_types = [str for _ in range(n_dims)]
        dim_names = get_dimension_names(n_dims)

        if overlapping:
            cubes_generator = overlapping_cube_generator(dim_types)
        else:
            cubes_generator = non_overlapping_cube_generator(dim_types)
            
        cubes = [next(cubes_generator) for _ in range(n_cubes_end + 1)]
        init_dim_manager(dim_names, dim_types)

        for n_cubes in n_cubes_options:
            for cls in hyper_cube_set_classes:
                logging.info(f'n_dims: {n_dims}, n_cubes: {n_cubes}, cls: {cls.__name__}.')

                # creation
                with Timer() as t:
                    s = cls(dim_names)
                    for cube in cubes[:n_cubes]:
                        converted_cube, active_dims = convert_cube(cube, cls, dim_types, dim_names)
                        s.add_cube(converted_cube, active_dims)
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'creation',
                    'time': t.elapsed_time
                })

                # add cube
                cube_to_add = cubes[n_cubes]
                superset = s.copy()
                with Timer() as t:
                    converted_cube, active_dims = convert_cube(cube_to_add, cls, dim_types, dim_names)
                    superset.add_cube(converted_cube, active_dims)
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'add_cube',
                    'time': t.elapsed_time,
                })

                # add hole
                cube_to_subtract = cubes[n_cubes // 2]
                subset = s.copy()
                with Timer() as t:
                    converted_cube, active_dims = convert_cube(cube_to_subtract, cls, dim_types, dim_names)
                    subset.add_hole(converted_cube, active_dims)
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'add_hole',
                    'time': t.elapsed_time,
                })

                # containment
                with Timer() as t:
                    out = subset.contained_in(s)
                assert out
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'contained_in',
                    'time': t.elapsed_time,
                })

                with Timer() as t:
                    out = s.contained_in(subset)
                assert not out
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'contained_in',
                    'time': t.elapsed_time,
                })

                # This is the check that takes most time with Z3ProductSet.
                with Timer() as t:
                    out = superset.contained_in(s)
                assert not out
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'contained_in',
                    'time': t.elapsed_time,
                })

                with Timer() as t:
                    out = s.contained_in(superset)
                assert out
                results.append({
                    'n_dims': n_dims,
                    'n_cubes': n_cubes,
                    'class': cls.__name__,
                    'operation': 'contained_in',
                    'time': t.elapsed_time,
                })

    return results


def run_experiment_and_plot(overlapping: bool):
    results_file = get_results_file(overlapping)
    results = run_experiment(overlapping)  # TODO: uncomment to re-run the experiment
    save_results(results, results_file)  # TODO: uncomment to re-run the experiment
    results = load_results(results_file)
    save_results_to_csv(results, results_file.with_suffix('.csv'))
    plot_results(results, overlapping)


def get_results_file(overlapping):
    if overlapping:
        stem = 'results_overlapping'
    else:
        stem = 'results_non_overlapping'
    results_file = Path(__file__).with_stem(stem).with_suffix('.json')
    return results_file


def main():
    for overlapping in [False, True]:
        run_experiment_and_plot(overlapping)


# TODO: write code that finds out which contained_in operation takes the longest with Z3.
def print_worst_contained_in_histogram():
    for overlapping in [True, False]:
        histogram = [0, 0, 0, 0]
        results_file = get_results_file(overlapping)
        results = load_results(results_file)
        results = filter_on_key_value(results, 'class', 'Z3ProductSet')
        results = filter_on_key_value(results, 'operation', 'contained_in')
        assert len(results) % 4 == 0

        for start_i in range(0, len(results), 4):
            single_set_results = results[start_i:start_i+4]
            max_i = 0
            for i in range(1, 4):
                if single_set_results[i]['time'] > single_set_results[max_i]['time']:
                    max_i = i
            histogram[max_i] += 1
        print(f'for overlapping={overlapping} the histogram is: {histogram}')


if __name__ == '__main__':
    # run_experiment_and_plot(overlapping=True)
    # main()
    print_worst_contained_in_histogram()
